//NOT ALLOWED CHARACTERS

// Less than ("<")
// Greater than (">")
// Double quote (")
// Pipe ("|")
// Backslash ("")
// Caret ("^")
// Left and right curly braces ("{" and "}")
// Tilde ("~")
// Grave accent or backtick ("`")
// add root directory if not found
// upload in location
// why it fail to return 405 in head method

#include <cstdlib>
#include <iostream>
#include <string>
#include <sstream>
#include <iomanip>

// Function to URL-decode a string
std::string urlDecode(const std::string& encoded) {
  std::ostringstream decoded;
  std::istringstream encodedStream(encoded);

  char ch;
  int hexValue = 0;
  while (encodedStream.get(ch)) {
    if (ch == '%') {
      if (encodedStream >> std::hex >> hexValue) {
        decoded << static_cast<char>(hexValue);
      }
    } else if (ch == '+') {
      decoded << ' ';
    } else {
      decoded << ch;
    }
  }

  return decoded.str();
}

int main() {
  std::string url = "https://www.example.com/search?query=hello%20world&page=1";

  // Step 1: Parse the URL and extract the query string
  size_t queryStringPos = url.find("?");
  std::string queryString = url.substr(queryStringPos + 1);

  // Step 2: Split the query string into key-value pairs
  std::string delimiter = "&";
  size_t pos = 0;
  std::string token;
  while ((pos = queryString.find(delimiter)) != std::string::npos) {
    token = queryString.substr(0, pos);
    // Step 3: Extract and decode parameters
    size_t equalPos = token.find("=");
    std::string key = token.substr(0, equalPos);
    std::string value = token.substr(equalPos + 1);

    // Decode URL-encoded value
    std::string decodedValue = urlDecode(value);

    // Step 4: Store query string in CGI environment variables
    setenv(key.c_str(), decodedValue.c_str(), 1);

    queryString.erase(0, pos + delimiter.length());
  }

  // Print environment variables
  extern char** environ;
  for (char** env = environ; *env != 0; ++env) {
    std::cout << *env << std::endl;
  }

  return 0;
}
